"""
Predictive Monitor â€” Trend Analysis and Forecasting
====================================================
Monitors system metrics and user patterns to predict future needs,
enabling proactive optimization and opportunity detection.

Standing on Giants: Time Series Analysis + Anomaly Detection + Forecasting
"""

import logging
import statistics
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum, auto
from typing import Any, Callable, Deque, Dict, List, Optional

logger = logging.getLogger(__name__)


class TrendDirection(Enum):
    """Direction of a detected trend."""

    RISING = auto()
    FALLING = auto()
    STABLE = auto()
    VOLATILE = auto()


class AlertSeverity(Enum):
    """Severity of predictive alerts."""

    INFO = auto()
    WARNING = auto()
    CRITICAL = auto()


@dataclass
class MetricReading:
    """A single metric reading."""

    name: str = ""
    value: float = 0.0
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TrendAnalysis:
    """Analysis of metric trend."""

    metric_name: str = ""
    direction: TrendDirection = TrendDirection.STABLE
    slope: float = 0.0  # Rate of change
    confidence: float = 0.0
    forecast_1h: Optional[float] = None
    forecast_24h: Optional[float] = None
    anomaly_score: float = 0.0  # 0-1, higher = more anomalous
    analyzed_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class PredictiveAlert:
    """Alert generated by predictive analysis."""

    id: str = ""
    metric_name: str = ""
    severity: AlertSeverity = AlertSeverity.INFO
    message: str = ""
    prediction: str = ""
    recommended_action: str = ""
    confidence: float = 0.0
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


class PredictiveMonitor:
    """
    Monitors metrics and predicts future trends.

    Capabilities:
    - Track multiple metrics over time
    - Detect trends (rising, falling, stable)
    - Forecast future values
    - Detect anomalies
    - Generate predictive alerts
    """

    def __init__(
        self,
        window_size: int = 100,
        anomaly_threshold: float = 2.5,  # Standard deviations
        alert_callback: Optional[Callable[[PredictiveAlert], None]] = None,
    ):
        self.window_size = window_size
        self.anomaly_threshold = anomaly_threshold
        self.alert_callback = alert_callback

        self._metrics: Dict[str, deque] = {}  # metric_name -> readings
        self._analyses: Dict[str, TrendAnalysis] = {}
        # PERF FIX: Use deque with maxlen for O(1) bounded storage
        self._alerts: Deque[PredictiveAlert] = deque(maxlen=100)
        self._alert_count = 0

    def record(
        self,
        name: str,
        value: float,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> None:
        """Record a metric reading."""
        if name not in self._metrics:
            self._metrics[name] = deque(maxlen=self.window_size)

        reading = MetricReading(
            name=name,
            value=value,
            metadata=metadata or {},
        )
        self._metrics[name].append(reading)

    def analyze(self, name: str) -> Optional[TrendAnalysis]:
        """Analyze trend for a specific metric."""
        if name not in self._metrics or len(self._metrics[name]) < 3:
            return None

        readings = list(self._metrics[name])
        values = [r.value for r in readings]

        analysis = TrendAnalysis(metric_name=name)

        # Calculate basic statistics
        mean = statistics.mean(values)
        stdev = statistics.stdev(values) if len(values) > 1 else 0

        # Calculate trend direction using linear regression
        n = len(values)
        if n >= 5:
            # Simple linear regression
            x_vals = list(range(n))
            x_mean = sum(x_vals) / n
            y_mean = mean

            numerator = sum((x - x_mean) * (y - y_mean) for x, y in zip(x_vals, values))
            denominator = sum((x - x_mean) ** 2 for x in x_vals)

            if denominator > 0:
                analysis.slope = numerator / denominator
                # R-squared for confidence
                y_pred = [y_mean + analysis.slope * (x - x_mean) for x in x_vals]
                ss_res = sum((y - yp) ** 2 for y, yp in zip(values, y_pred))
                ss_tot = sum((y - y_mean) ** 2 for y in values)
                analysis.confidence = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0

        # Determine direction
        if stdev > 0:
            normalized_slope = analysis.slope / stdev
            if normalized_slope > 0.1:
                analysis.direction = TrendDirection.RISING
            elif normalized_slope < -0.1:
                analysis.direction = TrendDirection.FALLING
            elif stdev / mean > 0.3 if mean != 0 else False:
                analysis.direction = TrendDirection.VOLATILE
            else:
                analysis.direction = TrendDirection.STABLE

        # Forecast
        if analysis.slope != 0:
            # 1 hour forecast (assuming ~1 reading per minute)
            analysis.forecast_1h = values[-1] + analysis.slope * 60
            # 24 hour forecast
            analysis.forecast_24h = values[-1] + analysis.slope * 1440

        # Anomaly detection (Z-score of latest value)
        if stdev > 0:
            z_score = abs(values[-1] - mean) / stdev
            analysis.anomaly_score = min(1.0, z_score / self.anomaly_threshold)

        self._analyses[name] = analysis
        return analysis

    def analyze_all(self) -> Dict[str, TrendAnalysis]:
        """Analyze all tracked metrics."""
        for name in self._metrics:
            self.analyze(name)
        return self._analyses.copy()

    def check_alerts(self) -> List[PredictiveAlert]:
        """Check for conditions that warrant alerts."""
        new_alerts = []

        for name, analysis in self._analyses.items():
            # Anomaly alert
            if analysis.anomaly_score > 0.8:
                alert = PredictiveAlert(
                    id=f"alert-{self._alert_count}",
                    metric_name=name,
                    severity=(
                        AlertSeverity.WARNING
                        if analysis.anomaly_score < 0.95
                        else AlertSeverity.CRITICAL
                    ),
                    message=f"Anomaly detected in {name}",
                    prediction="Current value deviates significantly from historical pattern",
                    recommended_action="Investigate root cause",
                    confidence=analysis.anomaly_score,
                )
                new_alerts.append(alert)
                self._alert_count += 1

            # Trend-based alerts
            if (
                analysis.direction == TrendDirection.RISING
                and analysis.confidence > 0.7
            ):
                if analysis.forecast_1h and analysis.forecast_1h > self._get_threshold(
                    name, "high"
                ):
                    alert = PredictiveAlert(
                        id=f"alert-{self._alert_count}",
                        metric_name=name,
                        severity=AlertSeverity.WARNING,
                        message=f"{name} trending up",
                        prediction=f"Forecast to reach {analysis.forecast_1h:.2f} in 1 hour",
                        recommended_action="Consider preemptive scaling or optimization",
                        confidence=analysis.confidence,
                    )
                    new_alerts.append(alert)
                    self._alert_count += 1

            elif (
                analysis.direction == TrendDirection.FALLING
                and analysis.confidence > 0.7
            ):
                if analysis.forecast_1h and analysis.forecast_1h < self._get_threshold(
                    name, "low"
                ):
                    alert = PredictiveAlert(
                        id=f"alert-{self._alert_count}",
                        metric_name=name,
                        severity=AlertSeverity.INFO,
                        message=f"{name} trending down",
                        prediction=f"Forecast to reach {analysis.forecast_1h:.2f} in 1 hour",
                        recommended_action="Monitor for potential degradation",
                        confidence=analysis.confidence,
                    )
                    new_alerts.append(alert)
                    self._alert_count += 1

        # Store and notify
        for alert in new_alerts:
            # PERF FIX: deque with maxlen auto-discards oldest (O(1))
            self._alerts.append(alert)
            if self.alert_callback:
                self.alert_callback(alert)

        return new_alerts

    def _get_threshold(self, metric_name: str, threshold_type: str) -> float:
        """Get threshold for a metric (override in subclass for custom thresholds)."""
        defaults = {
            "snr_score": {"high": 0.99, "low": 0.85},
            "ihsan_score": {"high": 0.99, "low": 0.95},
            "error_rate": {"high": 0.1, "low": 0.0},
            "latency_ms": {"high": 1000, "low": 0},
            "memory_usage": {"high": 0.9, "low": 0},
            "cpu_usage": {"high": 0.9, "low": 0},
        }

        metric_thresholds = defaults.get(
            metric_name, {"high": float("inf"), "low": float("-inf")}
        )
        return metric_thresholds.get(threshold_type, 0)

    def get_forecast(self, name: str, hours: float = 1.0) -> Optional[float]:
        """Get forecast for a metric at specified hours ahead."""
        analysis = self._analyses.get(name)
        if not analysis or analysis.slope == 0:
            return None

        readings = self._metrics.get(name)
        if not readings:
            return None

        current = readings[-1].value
        # Assume ~1 reading per minute
        return current + analysis.slope * (hours * 60)

    def stats(self) -> Dict[str, Any]:
        """Get monitor statistics."""
        return {
            "tracked_metrics": len(self._metrics),
            "total_readings": sum(len(r) for r in self._metrics.values()),
            "analyses": len(self._analyses),
            "total_alerts": len(self._alerts),
            "window_size": self.window_size,
        }


__all__ = [
    "AlertSeverity",
    "MetricReading",
    "PredictiveAlert",
    "PredictiveMonitor",
    "TrendAnalysis",
    "TrendDirection",
]
